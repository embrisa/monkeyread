**Project Context: Monkeyread - Dynamic Focus Challenge**

**1. Core Project Goal:**
Monkeyread is a fast-paced, focus-driven memory game designed to challenge and improve user's short-term memory and focus by recalling sequences of flashing letters (glyphs). The game's difficulty (display speed) dynamically adjusts based on player performance. The overall aim is an engaging and accessible brain-training experience.

**2. Technical Foundation & Key Files:**
   - **Language:** Vanilla JavaScript (ES6+), HTML5, CSS3.
   - **Primary Logic:** `public/script.js` contains all game mechanics, state management, DOM manipulation, event handling, dynamic speed adjustments, and scoring logic. **This is the most frequently modified file.**
   - **Structure:** `public/index.html` defines the UI elements and overall page layout. Element IDs are crucial for JavaScript interaction.
   - **Styling:** `public/style.css` handles all visual aspects. It utilizes CSS custom properties (variables) for theming (Banana/Jungle theme).
   - **Simplicity:** The project is a static web app with no backend and minimal external dependencies (only GoatCounter for analytics). Avoid introducing build steps or complex libraries unless specifically requested as part of the task.

**3. Key Coding Conventions & Architectural Patterns:**
   - **DOM Interaction:** Direct manipulation via `document.getElementById`, `classList`, and `style` properties.
   - **State Management:** Game state is managed by global variables within the `DOMContentLoaded` scope in `script.js`.
   - **Event Handling:** Listeners are typically attached directly to DOM elements (e.g., `element.addEventListener('click', ...)`).
   - **UI Updates:** Centralized functions (like `updateDisplays`) are preferred for refreshing dynamic content. Feedback messages use `messageDisplay.textContent` and associated CSS classes.
   - **Function Design:** Aim for descriptive function names and maintain a degree of functional cohesion where each function has a clear purpose.
   - **CSS:** Leverage existing CSS custom properties (e.g., `--color-primary-accent`, `--font-body`) and established class patterns. Prefer adding/removing classes over inline styles from JS.
   - **Readability:** Maintain and enhance code clarity with comments where necessary.
   - **Accessibility:** Be mindful of existing ARIA attributes and strive to maintain or improve accessibility.

**4. General Guidelines for ALL Modifications:**
   - **Consistency:** Ensure your changes are consistent with the existing coding style, naming conventions, and architectural patterns outlined above and observable in the codebase.
   - **File Structure Adherence:** Respect the current organization of HTML, JavaScript, and CSS.
   - **Impact Awareness:** Consider how changes in one part (e.g., `script.js`) might affect `index.html` (e.g., needing new IDs) or `style.css` (e.g., needing new classes or style adjustments).
   - **No Unnecessary Complexity:** Solutions should be as straightforward as possible within the existing project constraints.

**5. Timing & Animation:**
    - All game timing (letter flashing, pauses, re-flash cycles, etc.) **must use `requestAnimationFrame`** for accuracy and smoothness. Do **not** use `setTimeout` or `setInterval` for these purposes, as they are subject to browser throttling and can be inaccurate at high speeds.
    - This approach ensures that all visual updates are synchronized with the browser's rendering loop and the user's screen refresh rate, which is critical for perceptual accuracy in a fast-paced memory game like Monkeyread.

**6. Game Logic & Game Loop:**
The game loop in Monkeyread is designed around presenting sequences of letters to the player, capturing their input, and then adjusting game parameters like speed and score based on their performance. All timing-critical operations, such as letter flashing and countdowns, utilize `requestAnimationFrame` for accuracy and smooth visual updates.

**A. Game/Round Initialization:**
1.  **Starting or Advancing:**
    *   A new game is initiated by `startGame()` when the "Start Game" (or "Restart Game") button is clicked.
    *   Subsequent rounds begin with `advanceToNextRound()`, typically triggered after the player completes the previous round.
2.  **Setup for the Round (`proceedToNextRoundSetup()`):**
    *   The UI is reset for a clean start (`resetUIForNewRound()`): messages are cleared, buttons are set to their initial states, and the letter display area is hidden.
    *   A new sequence of unique letters is generated by `generateLetters()`. The number of letters (`numberOfLettersToDisplay`) is determined by the difficulty slider (ranging from 1 to 7 letters).
    *   A 1-second countdown, managed by `startCountdown()` (using `requestAnimationFrame`), is displayed in the `pauseCountdownDisplay` element. The main `flashing-letter` display remains hidden during this preparatory countdown.
3.  **Post-Countdown (`onNewRoundCountdownEnd()` callback):**
    *   Once the 1-second countdown concludes, `manageFlashAndInputCycle()` is called to commence the main gameplay sequence for the round.

**B. Core Round Cycle (`manageFlashAndInputCycle()`):**
1.  **State Preparation:**
    *   `flashCycleActive` (a boolean flag) is set to `true`, signaling that the letter flashing sequence is active.
    *   `reflashCount` (tracking re-flashes for the current round) is reset to 0.
    *   The "Submit Answer" and "Re-flash Letters" buttons are temporarily disabled.
    *   The `flashing-letter` display and any existing values in the letter input fields are cleared.
2.  **Letter Flashing Sequence (`flashLettersSequence()`):**
    *   This function is responsible for displaying the `currentLetters` one at a time. It employs `requestAnimationFrame` for precise control over the timing:
        *   An initial brief pause (`pauseBeforeMs`, currently 300ms) occurs before the first letter appears.
        *   Each letter in the sequence is displayed for a duration defined by `actualDisplaySpeed` (in milliseconds).
        *   A short pause (`pauseBetweenMs`, dynamically calculated based on `actualDisplaySpeed / 3`, with a minimum of 10ms) is inserted between consecutive letters.
        *   After the final letter has been displayed and its subsequent pause, the `flashing-letter` display is cleared.
3.  **Input Phase (`afterFlashShowInput()` callback):**
    *   This function is executed after `flashLettersSequence()` completes.
    *   The "Submit Answer" and "Re-flash Letters" buttons are enabled.
    *   Keyboard focus is automatically moved to the first letter input field, prompting the user for their answer.
    *   The game now awaits player input: either submitting their recalled sequence or requesting a re-flash.
    *   *(Note: The project documentation mentions a potential 3-second automatic re-flash if no input is given. However, the current implementation relies on a manual re-flash initiated by the player via the "Re-flash Letters" button.)*

**C. Player Actions & Consequences:**

1.  **Submitting an Answer (`handleAnswerSubmitted()`):**
    *   This function is triggered when the player clicks the "Submit Answer" button or presses the "Enter" key in the last input field (if all inputs are filled).
    *   `stopFlashCycle()` is called to immediately halt any ongoing `requestAnimationFrame` loops associated with letter flashing or countdowns.
    *   The player's input is retrieved from the letter input fields and validated (e.g., ensuring single letters are entered).
    *   **Scoring:**
        *   Points are awarded based on the correctness of the input: `POINTS_CORRECT_POSITION` for each correct letter in the correct spot, and `POINTS_CORRECT_WRONG_POSITION` for each correct letter in an incorrect spot.
        *   A `POINTS_PERFECT_ORDER_BONUS` is added if the entire sequence is recalled perfectly.
        *   The round's score is then modified by a `speedMultiplier` (higher for faster `actualDisplaySpeed` values) and a `reflashMultiplier` (each re-flash reduces the potential score for that round, currently by 20% per re-flash: `1 - reflashCount * 0.20`).
    *   **Speed Adjustment:**
        *   The `actualDisplaySpeed` is dynamically adjusted based on performance:
            *   **Correct/Perfect:** Speed decreases (game gets faster). The amount of decrease is determined by `calculateSpeedDecrease()`, which provides a larger reduction for perfect rounds and ensures the speed doesn't fall below `minPracticalDisplaySpeed` (a value estimated based on the display's refresh rate, defaulting to around 16ms or the estimated frame interval).
            *   **Incorrect:** If a penalty condition is met (e.g., majority of guessed letters are completely wrong and no letter was in the correct position), `actualDisplaySpeed` increases by `mistakeSpeedPenalty` (game gets slower), capped by `maxDisplaySpeed`.
    *   **Feedback:** A comprehensive feedback message is displayed to the user, typically including their guess, the correct answer, points awarded for the round, the new `actualDisplaySpeed`, and an encouraging message with emojis.
    *   **Game Progression:**
        *   If the `currentRound` number reaches `MAX_ROUNDS`, the `endGame()` function is called.
        *   Otherwise, the "Submit Answer" button's text and behavior change to "Next Round" (via `setSubmitButtonMode('next')`). A hint ("Press Enter to start next round") becomes visible. Clicking this button or pressing Enter (handled by a global keydown listener) will then call `advanceToNextRound()` to start the cycle anew.

2.  **Requesting a Re-flash (`handleReflashRequest()`):**
    *   This function is triggered when the player clicks the "Re-flash Letters" button.
    *   `reflashCount` for the current round is incremented.
    *   The "Submit Answer" and "Re-flash Letters" buttons are temporarily disabled.
    *   A 1-second countdown (using `startCountdown()` and `requestAnimationFrame`) is initiated, with its progress shown in `pauseCountdownDisplay`.
    *   Once this countdown completes (`onReflashCountdownEnd()` callback), `flashLettersSequence()` is called again to re-display the *same* `currentLetters` sequence.
    *   After the re-flashed sequence is shown (`afterReflashSequenceCompletes()` callback), the "Submit Answer" and "Re-flash Letters" buttons are re-enabled, and keyboard focus is returned to the first letter input field.

**D. Game End (`endGame()`):**
1.  The `gameActive` flag is set to `false`.
2.  `stopFlashCycle()` is called to ensure all animation loops are terminated.
3.  A final game-over message is constructed and displayed. This message includes the total `score`, the `numberOfLettersToDisplay` (difficulty) at which the game ended, the `MAX_ROUNDS` played, and a performance-based title/rank with accompanying emojis (e.g., "Banana Beginner," "Monkey Master," "Banana King"). The title is chosen from `scoreBrackets` based on a normalized score (score per letter displayed).
4.  The "Start Game" button's text changes to "Play Again?", prompting the user to start a new session.
5.  The difficulty slider, which is disabled during active gameplay, is re-enabled.
6.  The "Next Round" hint is hidden.

**E. Key State Variables & Functions:**
*   **Primary State Variables:** `gameActive`, `currentRound`, `score`, `currentLetters` (array of letters for the round), `numberOfLettersToDisplay` (difficulty setting), `actualDisplaySpeed` (duration each letter is shown), `reflashCount`, `flashCycleActive` (boolean indicating if a flash sequence is in progress or expected), `MAX_ROUNDS`.
*   **Core Game Logic Functions:** `startGame()`, `proceedToNextRoundSetup()`, `manageFlashAndInputCycle()`, `flashLettersSequence()`, `handleAnswerSubmitted()`, `handleReflashRequest()`, `endGame()`.

This game loop continues, round by round, until `MAX_ROUNDS` are completed, at which point the game ends and awaits the player's decision to play again.

**8. User Experience Flow:**
1. Click "Start Game". A 1-second millisecond countdown appears in the letter display area.
2. Letters flash in sequence.
3. Input area and buttons appear. User can submit an answer or re-flash the sequence (with penalty).
4. After submitting, feedback and score are shown. Only the Next Round button is enabled, with a hint for Enter.
5. User clicks Next Round or presses Enter to continue. The cycle repeats.

**9. Accessibility & UI:**
- All interactive elements are accessible by keyboard.
- The countdown, letter flashes, and feedback are visually clear and high-contrast.
- The Enter-to-continue hint is always present in the HTML and styled via CSS.

**10. Key CSS Classes & IDs:**
- **Layout & Structure:**
    - `.container`: The main wrapper for all game content, providing a consistent centered layout and background.
    - `#game-options`: Container for game settings like difficulty.
    - `#controls-area`: Holds main action buttons like "Start Game", "Next Round".
    - `#letter-display-area`: The prominent block where letters are flashed to the user.
    - `#input-area`: Contains the letter input fields and the submit button.
    - `#score-area`: Displays current round, score, accuracy, and speed.
    - `#instructions`: Section for game rules and how-to-play information.
    - `.how-fast-section`: Container for the informational text about visual perception speed.
- **Buttons & Interactivity:**
    - `.button`: Base class for all buttons, providing common styling.
    - `.button-primary`, `.button-secondary`, `.button-submit`: Variants of the base button style for different actions.
    - `*:focus-visible`: Provides a consistent focus outline for accessibility on all focusable elements.
- **Game Elements & Feedback:**
    - `#flashing-letter`: The `<span>` inside `#letter-display-area` that shows the individual letters during the sequence.
    - `.letter-inputs-wrapper input[type="text"]`: Styles for the individual letter input boxes.
    - `#message`: The paragraph element used to display feedback messages to the user (e.g., correct, incorrect).
    - `#message.correct`, `#message.incorrect`, `#message.bonus`: Modifier classes applied to `#message` to style it based on the type of feedback.
    - `#pause-countdown-display`: Displays the 1-second countdown before letters are flashed.
- **State & Utility:**
    - `.hidden`: A utility class to hide elements by setting `display: none !important;`.
    - `#difficulty-slider`: The range input slider for selecting game difficulty.
    - `#difficulty-value`: Displays the current numerical value of the difficulty slider.
- **Theming (CSS Custom Properties in `:root`):**
    - `--color-bg`, `--color-text`, `--color-primary-accent`, etc.: Define the core color palette (Banana/Jungle theme).
    - `--font-heading`, `--font-body`: Define the primary typefaces used.
    - `--border-radius-soft`, `--shadow-subtle`: Define common stylistic values for consistency.
